# Index를 B+tree로 구성하는 이유
## 개요
- 데이터 검색시 hash table의 시간복잡도는 O(1)이고 b+tree는 O(logN)으로 더 느린데 왜 index를 b+tree로 구현하나요?
- hash table은 하나의 데이터를 탐색하는 시간은 O(1)으로 더 빠르지만 값이 정렬되어 있지 않기 때문에 부등호를 사용하는 query에 있어서는 매우 비효율적
- b+tree는 데이터가 정렬되어 있기 때문에 부등호를 사용하는 query에 있어서 hash table보다 빠름

## TIP
- 하나의 값만 가져올 때는 hash table이 낫다는 점을 언급
- 일정 범위의 값을 찾을 때는 b+tree가 적합하다고 대답
- b+tree에 대해 제대로 이해하고 있는지, index의 작동원리와 구조를 제대로 이해하고 있는지 알기 위한 질문

## 왜 B+tree?
- 항상 정렬된 상태를 유지하여 부등호 연산에 유리
- 데이터 탐색 뿐 아니라 저자으 수정, 삭제에도 항상 O(log N)의 시간복잡도
- b+tree는 루트 노드부터 비교해가면서 리프 노드를 찾아 내려감
- 리프 노드는 서로 연결되어 있어 부등호 연산에 대응

## Hash index
- 빠른 단일 데이터 검색에 유용(O(1))
- index로 hash index를 사용할 경우 단일 검색, 즉 등로 연산에만 특화되어있기 때문에 사용이 제한적
- 데이터가 조금이라도 달라지면 hash 값이 완전히 달라지므로 부등호 연산이 자주 사용되는 DB 검색에서 hash index는 적합하지 않음

