# Queue VS Priority Queue

## 핵심 답변

- Queue는 먼저 들어간 항목이 먼저 나오는 선입선출(FIFO) 자료구조
- Priority Queue는 우선순위가 높은 항목이 먼저 나오는 자료구조
- 시간복잡도는 Queue는 O(1), Priority Queue는 O(logN)

## TIP

- 우선순위큐의 구현 방법과 operation의 시간복잡도를 잘 설명해야 함
- 우선순위큐를 구현하라고 한다면 Heap을 구현하면 됨
- 힙은 이진완전트리를 활용하고 push, pop O(logN)의 시간복잡도 가짐
- tree가 그려진 상태에서 최대힙, 최소힙의 삽입, 삭제시 어떻게 노드가 삭제되고 연결되는지 과정을 그림으로 설명할 수 있어야

## Heap

- 우선순위큐의 구현과 일치
- 완전이진트리 구조
- 각 노드에 저장된 값은 해당 노드의 자식노드보다 크거나 같음(최대힙)
    - 루트 노드에 저장된 값이 가장 큰 값
- 각 노드에 저장된 값은 해당 노드의 자식노드보다 작거나 같음(최소힙)
    - 루트 노드에 저장된 값이 가장 작은 값

## Heap 구현

- 트리는 보통 연결 리스트로 구현하지만 힙은 배열로 구현
    - 새로운 노드를 힙의 마지막 위치에 추가해야 하는데 이 때 배열 기반 구현이 수월
- 0번째 index는 사용 X
- 완전 이진 트리의 특성을 활용하여 배열의 index만으로 부모 자식 간의 관계를 정의
    - n번째 노드의 왼쪽 자식 노드: 2n
    - n번째 노드의 오른쪽 자식 노드: 2n+1
    - n번째 노드의 부모 노드: n/2
- 최대힙
  - push
    - 새로운 데이터를 push하면 heap의 맨 마지막 인덱스에 값 저장
    - 부모 노드의 값이 더 작다면 swap
    - 부모 노드의 값이 더 크거나 같다면 swap 종료
  - pop
    - 첫번째 인덱스에 저장되어 있는 값 pop
    - 마지막 인덱스 값을 top으로 옮김
    - top이 자식 노드보다 작다면 자식 노드 중 큰 값과 swap
    - top이 자식 노드보다 크거나 같다면 swap 종료
  - 시간복잡도는 heap의 높이가 logN이므로 push, pop 모두 O(logN) (swap 과정이 최대 logN번 수행됨)
  - 